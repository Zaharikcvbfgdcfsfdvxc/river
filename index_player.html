<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="RiverDub — авторская озвучка и дубляж для аудитории. Релизы, демо и библиотека выпусков.">
    <meta name="keywords" content="RiverDub, озвучка, дубляж, студия озвучки, фан-даб, авторская озвучка, русский дубляж, voice over">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="RiverDub — студия озвучки">
    <meta property="og:description" content="Авторская озвучка и дубляж для аудитории. Релизы, демо и библиотека выпусков.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="img/logo.png">
    <title>RiverDub</title>
    <link rel="icon" type="image/png" href="img/logo.png">
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header class="top-bar">
     <a href="index.html" class="logo">
        <img src="img/logo.png" alt="Логотип RiverDub">
        <span>RiverDub</span>
    </a>

    <form class="search">
        <input type="text" placeholder="Поиск видео" aria-label="Поиск">
        <button type="submit">Найти</button>
    </form>

    <nav class="nav">
        <a href="index.html">Главная</a>
        <a href="index_info.html">О нас</a>
        <a href="index_contacts.html">Контакты</a>
    </nav>
</header>

<main class="page player-page">
    <section class="player-layout">
        <div class="player-main">
            <div class="player-video-wrap">
                <video class="player-video" controls></video>
                <a class="next-floating" href="#" aria-label="Следующий ролик">Следующий ролик</a>
            </div>
            <div class="player-info">
                <div>
                    <p class="player-kicker" id="player-kicker">Видео</p>
                    <h1 id="player-title">Выберите видео</h1>
                    <p class="player-meta" id="player-meta"></p>
                </div>
            </div>
            <div class="player-desc">
                <p id="player-description"></p>
            </div>
        </div>

        <aside class="player-side">
            <div class="next-episode" id="next-episode">
                <p class="player-kicker">Следующий ролик</p>
                <div class="next-card">
                    <div class="next-thumb" id="next-thumb">—</div>
                    <div>
                        <h3 id="next-title">Пока нет</h3>
                        <p class="player-meta" id="next-meta"></p>
                    </div>
                </div>
            </div>
            <div class="other-videos">
                <p class="player-kicker">Другие видео</p>
                <div class="other-list" id="other-list"></div>
            </div>
        </aside>
    </section>
</main>

<footer class="footer">
    <p>(c) RiverDub Studio, 2024. <a href="index_admin.html">Все права защищены.</a></p>
</footer>

<script>
    (function () {
        const video = document.querySelector('.player-video');
        const nextButton = document.querySelector('.next-floating');
        const titleEl = document.getElementById('player-title');
        const kickerEl = document.getElementById('player-kicker');
        const metaEl = document.getElementById('player-meta');
        const descEl = document.getElementById('player-description');
        const nextThumb = document.getElementById('next-thumb');
        const nextTitle = document.getElementById('next-title');
        const nextMeta = document.getElementById('next-meta');
        const otherList = document.getElementById('other-list');

        const typeLabels = {
            video: 'Видео',
            demo: 'Демо-ролик',
            background: 'Фон'
        };

        const parseNumber = (value) => {
            const num = Number(value);
            if (!Number.isFinite(num) || num <= 0) return null;
            return Math.floor(num);
        };

        const getSeasonEpisode = (item) => {
            const season = parseNumber(item.season);
            const episode = parseNumber(item.episode);
            if (season && episode) {
                return { season, episode };
            }
            return null;
        };

        const normalizeText = (value) =>
            String(value || '')
                .toLowerCase()
                .replace(/ё/g, 'е')
                .replace(/[^a-zа-я0-9]+/gi, ' ')
                .trim();

        const stripEpisodeMarkers = (value) =>
            value
                .replace(/(?:сезон|season|s)\s*\d{1,2}/gi, ' ')
                .replace(/(?:серия|сер\.?|эпизод|episode|ep|e)\s*\d{1,3}/gi, ' ')
                .replace(/\d{1,2}\s*[xх]\s*\d{1,3}/gi, ' ')
                .replace(/\d{1,3}/g, ' ');

        const parseTitleMeta = (title) => {
            const lower = String(title || '').toLowerCase().replace(/ё/g, 'е');
            let season = null;
            let episode = null;
            let match = lower.match(
                /(?:сезон|season|s)\s*(\d{1,2})\s*(?:серия|сер\.?|эпизод|episode|ep|e)\s*(\d{1,3})/i
            );
            if (match) {
                season = parseNumber(match[1]);
                episode = parseNumber(match[2]);
            }
            if (!season || !episode) {
                match = lower.match(/(\d{1,2})\s*[xх]\s*(\d{1,3})/i);
                if (match) {
                    season = parseNumber(match[1]);
                    episode = parseNumber(match[2]);
                }
            }
            if (!episode) {
                match = lower.match(/(?:серия|сер\.?|эпизод|episode|ep|e)\s*(\d{1,3})/i);
                if (match) {
                    episode = parseNumber(match[1]);
                }
            }
            if (!episode) {
                match = lower.match(/\b(\d{1,3})\b/);
                if (match) {
                    episode = parseNumber(match[1]);
                }
            }
            const baseTitle = normalizeText(stripEpisodeMarkers(lower));
            return { season, episode, baseTitle };
        };

        const levenshtein = (a, b) => {
            if (a === b) return 0;
            const alen = a.length;
            const blen = b.length;
            if (alen === 0) return blen;
            if (blen === 0) return alen;
            const matrix = Array.from({ length: alen + 1 }, () => new Array(blen + 1));
            for (let i = 0; i <= alen; i += 1) matrix[i][0] = i;
            for (let j = 0; j <= blen; j += 1) matrix[0][j] = j;
            for (let i = 1; i <= alen; i += 1) {
                for (let j = 1; j <= blen; j += 1) {
                    const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j - 1] + cost
                    );
                }
            }
            return matrix[alen][blen];
        };

        const titleSimilarity = (a, b) => {
            if (!a || !b) return 0;
            if (a === b) return 1;
            if (a.includes(b) || b.includes(a)) return 0.9;
            const dist = levenshtein(a, b);
            return 1 - dist / Math.max(a.length, b.length);
        };

        const findNextByTitle = (current, list) => {
            const currentMeta = parseTitleMeta(current.title);
            if (!currentMeta.episode) return null;
            const targetEpisode = currentMeta.episode + 1;
            const candidates = list
                .map((item) => {
                    const meta = parseTitleMeta(item.title);
                    return {
                        item,
                        meta,
                        similarity: titleSimilarity(currentMeta.baseTitle, meta.baseTitle)
                    };
                })
                .filter(({ meta, similarity }) => meta.episode === targetEpisode && similarity >= 0.6);
            if (!candidates.length) return null;
            candidates.sort((a, b) => b.similarity - a.similarity);
            return candidates[0].item;
        };

        const buildMetaLine = (item) => {
            const label = typeLabels[item.type] || '\u0412\u0438\u0434\u0435\u043e';
            const parts = [label];
            const meta = getSeasonEpisode(item);
            if (meta) {
                parts.push(`\u0421\u0435\u0437\u043e\u043d ${meta.season} \u2022 \u0421\u0435\u0440\u0438\u044f ${meta.episode}`);
            }
            const dateLabel = formatDate(item.created_at);
            if (dateLabel) {
                parts.push(dateLabel);
            }
            return parts.join(' \u2022 ');
        };


        const formatDate = (value) => {
            if (!value) return '';
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) return '';
            return date.toLocaleDateString('ru-RU');
        };

        const params = new URLSearchParams(window.location.search);
        const id = params.get('id');
        if (!id) {
            titleEl.textContent = 'Выберите видео из библиотеки';
            return;
        }

        fetch(`/api/videos/${id}`)
            .then((res) => res.ok ? res.json() : null)
            .then((item) => {
                if (!item) {
                    titleEl.textContent = 'Видео не найдено';
                    return;
                }
                titleEl.textContent = item.title;
                kickerEl.textContent = typeLabels[item.type] || 'Видео';
                metaEl.textContent = buildMetaLine(item);
                descEl.textContent = item.description || '';
                video.src = item.url;
                if (item.preview_url) {
                    video.poster = item.preview_url;
                }
                video.load();

                const threshold = Math.min(Math.max(Number(item.threshold || 90), 60), 99);
                const toggleNext = () => {
                    if (!isFinite(video.duration) || video.duration <= 0) {
                        return;
                    }
                    const progress = video.currentTime / video.duration;
                    nextButton.classList.toggle('visible', progress >= threshold / 100);
                };
                video.addEventListener('timeupdate', toggleNext);
                video.addEventListener('ended', () => nextButton.classList.add('visible'));
            });

        fetch('/api/videos')
            .then((res) => res.ok ? res.json() : [])
            .then((videos) => {
                const cleaned = videos.filter((item) => item.type !== 'interview');
                const current = cleaned.find((item) => String(item.id) === String(id));
                const candidates = current
                    ? cleaned.filter((item) => String(item.id) !== String(id) && item.type === current.type)
                    : [];

                const findNextBySeason = (currentItem, list) => {
                    const currentMeta = getSeasonEpisode(currentItem);
                    if (!currentMeta) return null;
                    const direct = list.find((item) => {
                        const meta = getSeasonEpisode(item);
                        return meta && meta.season === currentMeta.season && meta.episode === currentMeta.episode + 1;
                    });
                    if (direct) return direct;
                    const nextSeason = list
                        .map((item) => ({ item, meta: getSeasonEpisode(item) }))
                        .filter(({ meta }) => meta && meta.season === currentMeta.season + 1);
                    if (!nextSeason.length) return null;
                    nextSeason.sort((a, b) => a.meta.episode - b.meta.episode);
                    return nextSeason[0].item;
                };

                let nextItem = null;
                if (current) {
                    nextItem = findNextBySeason(current, candidates) || findNextByTitle(current, candidates);
                }
                if (nextItem) {
                    const nextLabel = typeLabels[nextItem.type] || '\u0412\u0438\u0434\u0435\u043e';
                    nextThumb.textContent = nextLabel;
                    if (nextItem.preview_url) {
                        nextThumb.style.backgroundImage = `url('${nextItem.preview_url}')`;
                        nextThumb.style.backgroundSize = 'cover';
                        nextThumb.style.backgroundPosition = 'center';
                    } else {
                        nextThumb.removeAttribute('style');
                    }
                    nextTitle.textContent = nextItem.title;
                    nextMeta.textContent = buildMetaLine(nextItem);
                    nextButton.href = `index_player.html?id=${nextItem.id}`;
                    nextButton.classList.remove('disabled');
                } else {
                    nextButton.href = '#';
                    nextButton.classList.add('disabled');
                    nextThumb.textContent = '\u2014';
                    nextThumb.removeAttribute('style');
                    nextTitle.textContent = '\u041f\u043e\u043a\u0430 \u043d\u0435\u0442';
                    nextMeta.textContent = '';
                }

                const others = cleaned.filter((item) => String(item.id) !== String(id)).slice(0, 3);
                otherList.innerHTML = '';
                if (!others.length) {
                    otherList.innerHTML = '<p class="contact-meta">Пока нет других видео.</p>';
                    return;
                }
                others.forEach((item) => {
                    const card = document.createElement('article');
                    card.className = 'other-card';
                    const thumbStyle = item.preview_url
                        ? `style="background-image: url('${item.preview_url}'); background-size: cover; background-position: center;"`
                        : '';
                    card.innerHTML = `
                        <div class="other-thumb" ${thumbStyle}>${typeLabels[item.type] || 'Видео'}</div>
                        <div>
                            <h4>${item.title}</h4>
                            <p class="player-meta">${formatDate(item.created_at)}</p>
                        </div>
                    `;
                    card.addEventListener('click', () => {
                        window.location.href = `index_player.html?id=${item.id}`;
                    });
                    otherList.appendChild(card);
                });
            });
    })();
</script>
<script src="script.js"></script>
</body>
</html>

